{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":3570625826605070031,"abi":{"parameters":[{"name":"null_hash","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"vote","type":{"kind":"boolean"},"visibility":"public"},{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"index","type":{"kind":"field"},"visibility":"private"},{"name":"leaves","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"22":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"23":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"24":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"61":{"source":"use std::hash::poseidon::bn254::hash_1;\nuse std::hash::poseidon::bn254::hash_2;\nuse trees::merkle::MerkleTree;\n\nfn main(\n    null_hash: pub Field,\n    nullifier: Field,\n    secret: Field,\n    root: pub Field,\n    vote: pub bool,\n    depth: pub u32,\n    index: Field,\n    leaves: [Field; 16],\n) {\n    let computed_nullifier_hash: Field = hash_1([nullifier]);\n    assert(computed_nullifier_hash == null_hash);\n    let bits: [u1; 8] = index.to_le_bits();\n    let null_hash: Field = hash_1([nullifier]);\n}\n","path":"/home/edmondm/Repositories/Dapps/zk-voting/packages/circuits/src/main.nr"}},"names":["main"],"brillig_names":["directive_to_radix"]}